% !TEX root = /home/frank/School/thesis_text/thesis.tex


\chapter{High Level Synthesis}



A recurring theme in the literature is the relative difficulty of implementing an algorithm on an FPGA compared to conventional implementation techniques on CPU's and GPU's. Both development time and place-and-route take considerably more time compared to programming and compiling for more traditional architectures \cite{inta_chimera:_2012,tsoi_axel:_2010}. With an increase in the complexity required to perform a task also comes an increase in the difficulty of designing and debugging such a system. 
High level synthesis tools enable a user to specify the behavior of a system in a high level programming language and convert this description into usable hardware. Most tools use the C, C++ or sytstemC programming languages, however other programming languages such as the functional programming language Haskell \cite{baaij2010c}, the scripting language Python\cite{decaluwe2004myhdl} or Matlab M-code\cite{hdlcoder} have been used. These tools enable faster prototyping and implementation\cite{che_accelerating_2008}. These tools also enable programmers without a background in HDL design to benefit from the advantages of FPGA accelerators without facing the steep learning curve of learning a HDL such as VHDL or Verilog. For HDL designers these tools increase productivity by allowing the designer to describe the desired behavior using less code.\cite{casseau_c-_2005}. 
These tools enable to shift the focus from low-level implementation details to the development and improvement of the algorithm in a rapid prototyping fashion\cite{wakabayashi_c-based_2004}.
HLS tools have a long history dating back to the 1970's, but only recently have these tools matured enough to become adopted by industry. These tools present an interesting evolution and a possible paradigm shift in hardware design and prototyping\cite{cong_high-level_2011}.



\section{Riverside Optimizing Compiler for Configurable Computing} 
ROCCC is a C-to-VHDL compiler which focuses on FPGA based code acceleration. It implements a subset of the C language on which it performs loop analysis techniques to provide increasing throughput with less usage of area\cite{martin_high-level_2009}. The generated VHDL is independent from FPGA platforms and supports code reuse through the use of modules. 
ROCCC uses the streaming paradigm, in which data is represented by streams, a data format similar to the way arrays are stored in memory. These streams pass through a set of operations called kernels. This particular way of representing data makes it possible to express parallelism and is relatively easy mapped to the FPGA hardware. This paradigm removes the need for area-costly soft-core processors\cite{buyukkurt_impact_2006}.\\
This streaming paradigm is also what enables the platform independence of the ROCCC hardware. As long as the data is delivered to the system in the form of a stream it can be used.
Another important feature of ROCCC are the so-called smart buffers. These attempt to utilize the data-locality of certain applications to increase the performance. This is achieved through intelligent data reuse which minimizes the number of off-chip memory accesses. 

\section{Xilinx Vivado High Level Synthesis Tool}
\label{sec:vivado_HLS}
Vivado High-Level Synthesis is part of the Xilinx Vivado design suite. It is the product of the acquisition of AutoESL and the re-branding of their AutoPilot High-Level Synthesis tool. Vivado represents the next evolution of Xilinx tools fitting in their vision of an \quotationmarks{all programmable world}.  It allows C, C++ and SystemC code to be synthesized into VHDL or Verilog code. Functional simulation can be done in C, which is a great improvement over the typical VHDL or Verilog simulation. The Vivado tool is based on the Eclipse platform and incorporates the C Development tool (CDT).[15]
\\
Vivado HLS was as the HLS tool for this thesis because of it's integration in the Xilinx toolchain and \emph{out-of-the-box} support for the Zynq platform.

